1) 用户（老师）创建房间：
	客户端：向服务器emit，create-room事件，携带数据：学号范围，限定时间，（老师当前位置）

	服务器端：监听create-room事件了
		1. 把创建房间的这个用户的socket放进一个新的room（socket.join(room)），根据目前房间数目作为room的名字（roomID），roomID == roomCount
		2. 把room和创建房间的这个用户的socket关联起来：currentRoom[socket.id] = room
		3. 把这个代号放进一个数组rooms[roomCount]中存放
		4. 新建一个新的对象A存放客户端携带过来的数据，这个对象包含：roomID，学号范围，限定时间，（老师当前位置），学生列表（是一个数组，里面的元素是布尔值，默认为false，下标根据学号范围来设定）
		5. 把这个新对象放进roomsInfo[roomID]数组中存放
		6. 把这个新对象放进对象feedBack
		6. 向客户端emit，createRoomFeedBack事件，携带数据是feedBack，返回这次“新建”房间的信息（那个新的对象A）给客户端

	客户端：
		1. 监听createRoomFeedBack事件，接收到返回的房间信息，并渲染在now-room-teacher页面
		2. 此时开始根据限定时间来“计时”，当计时结束时再向服务器emit，timeOut事件

2）用户（学生）签到：
	客户端：向服务器emit，check-in事件，携带数据：签到房间的ID，签到学号，（学生当前位置）

	服务器端：
		监听check-in事件，先判断传过来的数据：
			1. 签到房间ID是否在rooms[]中有（是否存在房间）
			2. 签到的学号是否超出该房间的签到学号范围（根据roomID，在roomsInfo[]数组中找到那个房间的详细信息，里面就可以找到该房间的学号范围）
			（3. 该学生的当前位置和老师的当前位置是否在50米以内）
		符合以上条件的话，就可以把这个socket加入到该房间里面，即socket.join(room)
			每当有新socket加入room时：
			1. 就向那个room里面的其他socket广播
			2. 根据签到学号，把 roomInfo[roomID].学生列表[签到学号] 设置为true
			3. 把roomInfo[roomID]放进一个对象feedBack里面

		如果不符合以上条件的话，不能加入这个房间，在对象feedBack里面放入不能加入房间的原因

		向客户端emit，checkInFeedBack事件，携带数据是feedBack，返回这次“签到”的反馈

	客户端：
		1. 监听checkInFeedBack事件，接收到签到“反馈”后，把信息渲染在now-room-student页面

3）计时结束
	当客户端的计时结束时，
	客户端：向服务器emit，timeOut事件，携带数据是：roomID

	服务器：
		1. 监听timeOut事件，根据接收过来的roomID，找到相应的roomInfo[roomID]
		2. 向客户端emit，checkInResult事件，携带数据是相应的roomInfo[roomID]
		3. 把rooms[roomID]这个元素清除掉
		4. 把roomInfo[roomID]这个元素清除掉
		5. 把currentRoom[socket.id] = room 清除掉
		6. 把这个room里面的socket全部清除掉（即清除掉这个room。https://stackoverflow.com/questions/23342395/how-to-delete-a-room-in-socket-io）

	客户端：监听checkInResult事件，渲染check-in-result页面




（now-room-teacher页面和now-room-student页面的区别：

）